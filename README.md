# Lab-5-1
# Lab-4
## Сабуров Сергей Фт-200008
## Добавлен диалог с пользователем и ошибка ввода
## Лабораторная номер 4 Такси
### Описание программы
Такси
После затянувшегося совещания директор фирмы решил заказать такси, чтобы развезти сотрудников по домам. Он заказал N машин — ровно столько, сколь у него сотрудников.
Однако когда они подъехали, оказалось, что у каждого водителя такси свой тариф за 1 километр. Директор знает, какому сотруднику сколько километров от работы до дома
(к сожалению, все сотрудники живут в разных направлениях, поэтому нельзя отправить двух сотрудников на одной машине). Теперь директор хочет определить,
какой из сотрудников на каком такси должен поехать домой, чтобы суммарные затраты на такси (а их несет фирма) были минимальны.
### ПО Visual studio 2019
#### КОД
```
#include <iostream>
#include <Windows.h>//библиотека для русского ввода/вывода
#include <string> //стринговая библиотека
#include <sstream>

int main()
{
    SetConsoleCP(1251);//русский ввод
    SetConsoleOutputCP(1251);//вывод
    int check = 0;
    int p;
    int h = 0;//если не занулить не работает
    int n;
    int o;
    char c;//для символа строки
    std::string s = "Результат: ";
    std::string m;//сама строка
    std::string z;//сама строка
    std::string l = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
    while (check < 1)
    {
        std::cout << "Введите шаг шифрования число от (-33 до 33) n= ";
        std::cin >> n;//если n огромно всё ломается фиксим
        if ((n < 0) | (n > -1))
        {
            std::cout << "Ввод шага выполнен" << std::endl;
            while (n < 0)
            {
                n = 33 - fabs(n);//добавил фикс для отрицательного шага, в исходном задании не заметил)
            }
            check = 1;
        }
        else
            std::cout << "Ввод шага невыполнен, пользователь допустил ошибку ввода" << std::endl;
    }
    n = n % 33;//если n огромно упрощает нам жизнь
    check = 0;
    std::cout << "Введите строку для шифрования русскими буквами " << std::endl;
    std::cin >> z;// столкнулся с проблемой гетлайн пропускает первое слово. для этого использовал конструкцию конкатенации строк з и м где м считывает до пробела а м после.
    std::getline(std::cin, m);
    m = z + m;

    std::string::iterator end_pos = std::remove(m.begin(), m.end(), ' ');
    m.erase(end_pos, m.end());//чистим пробелы из строки
    //std::cout << m << std::endl;//проверка чистки пробелов получается строка для шифровки не думаю что будет лишним показать что шифруется
    p = m.length();//для цикла, немного экономим память
    for (int i = 0; i < p; i++)
    {
        c = m[i];//берем итый символ
        h = l.find_first_of(c);//ищем символ в строке алфавита
        o = n + h;//добавляем шаг кодировки найденному номеру символа алфавита
        if (o >= 33)//если символ превысит алфавит то начинаем с абв снова
        {
            o -= 33;
        }
        m[i] = l[o];//присваиваем итому значению новый символ
        h = 0;
    }
    std::cout << "Вывод полученной строки:" << std::endl;
    std::cout << m << std::endl;
    return 0;
}

```
### Скриншоты тестов с прошлого релиза
Первый Тест
![image](https://user-images.githubusercontent.com/90544365/135321380-f5cccbd7-3df1-4600-9269-e72dbad3b459.png)
Второй Тест
![image](https://user-images.githubusercontent.com/90544365/135321518-32865bd0-b2f5-4232-80b6-d5acaac9cbd0.png)
Третий мой личный более сложный
![image](https://user-images.githubusercontent.com/90544365/135321734-8f61cc85-f99e-4ca9-ba8d-a67f8af8d84d.png)
